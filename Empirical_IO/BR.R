#install.packages('tidyverse', 'ggplot2')

library(tidyverse)
library(ggplot2)

# setwd('/Users/olga/Downloads/')

df <- read.csv('BresnahanAndReiss1991_DATA.csv')

head(df)

# Графики ----------------------------------------------------------------------
###
###
a <- cut(df$TPOP, c(seq(0, 8, by=1), Inf))
df$TPOP_cut <- a

a <- df %>%
  group_by(TPOP_cut, TIRE) %>%
  summarise(n = n())
a 

ggplot(a, aes(x=TPOP_cut, y=n, fill = TIRE )) + 
  geom_bar(position="stack", stat="identity")

###

# Оптимизация ------------------------------------------------------------------

## Переменная функция ----------------------------------------------------------

V <- function(n, a, b, df){
  a[1] + b[1] * df$ELD + b[2] * df$PINC + b[3] * df$LNHDD + b[4] * df$FFRAC - # обратите внимание, что здесь минус
    if(n >= 2) sum(a[2:n]) else 0 # сумма альф, начиная со второй
  
  # Лирическое отступление - почему здесь нужен if(n >= 2) ... else 0
  # Можно было бы просто сделать sum(a[2:n]) и он бы так же суммировал.
  # Проблема возникает, если n==1, потому что a[2:1] тоже легальная команда,
  # но она дает альфы в обратном порядке (alpha2, alpha1). А нам надо, чтобы
  # в случае n==1 ничего не происходило. Поэтому в явном виде пишем это условие
}

## Постоянная функция ----------------------------------------------------------

f <- function(n, g, df) {g[1] + g[6] * df$LANDV + if (n >= 2) sum(g[2:n]) else 0}

## Наша основная Likelihood function -------------------------------------------
lLik <- function(theta, df) {
  # Оптимизатор работает с одним вектором, его нужно разобрать по параметрам
  # У нас будет такая последовательность коэффициентов:
  # lambda <- [1:4], beta <- [5:8], alpha <- [9:13], gamma <- [14:19]
  l <- theta[1:4]
  b <- theta[5:8]
  a <- theta[9:13]
  g <- theta[14:19]
  
  # Объем рынка
  S <- df$TPOP + l[1]*df$OPOP + l[2]*df$NGRW + l[3]*df$PGRW + l[4]*df$OCTY
  # TPOP - население, OPOP - население в округе, NGRW - уезжие, PGRW - приезжие, OCTY - путешественники
  
  # Вспомним форму функции прибыли
  # для простоты запомним ее как функцию от числа фирм pi=pi(n)
  
  
  pi <- function (n) S * V(n, a, b, df) - f(n, g, df)
  
  
  # сделаем список P[[N]], чтобы было куда записать вероятности, что на рынке N-1 компания
  # (N-1, потому что индекс в R не может идти с 0, а на рынке может быть 0 компаний)
  P <- list()
  
  P[[1]] <- 1-pnorm(pi(1)) # Отдельно, что на рынке никого нет
  for (i in 2:5) P[[i]] <- pnorm(pi(i-1)) - pnorm(pi(i)) # С 1 до 4 формула типовая, делаем цикл
  P[[6]] <- pnorm(pi(5)) # Отдельно, что на рынке 5 и более компаний
  
  P <- lapply(P,log) # потому что P - list, простой log(P) его не считает, надо lapply
  
  # Для оптимизации будем использовать алгоритм L-BFGS-B, а он не умеет в бесконечности, нужно причесать
  for (i in 1:6) P[[i]][ P[[i]] == -Inf ] <- -1e+08 
  
  # Наша функция должна вернуть меру правдоподобия. Инициализируем ее, записав 0
  lLik <- 0
  # Теперь для ситуации 0-5 компаний (а помним, что у нас это индексы 1-6) можно прогнать цикл
  # (без lLik <- 0 он бы ругался, так как пока в lLik ничего не было, операция lLik + sum(...) нелегальна)
  for (i in 1:6) lLik <- lLik + sum(P[[i]][df$TIRE == i-1]) 
  lLik <- lLik + sum(P[[6]][df$TIRE > 5]) # еще надо добавить, что мы правильно угадали там где более 5 компаний
  
  # нам надо максимизировать вероятность, а оптимизатор ищет минимум - развернем метрику
  return(-1 * lLik) 
}

# Запускаем алгоритм оптимизации
# !Важно! У параметров есть ограничения
# alpha, gamma > 0 (кроме gamma6 - она не ограничена)
# Ограничения задаются по порядку переменных, вспомним его:
# l <- [1:4], b <- [5:8], a <- [9:13], g <- [14:19]
# Значит мы должны получить такой вектор для нижней границы:
#    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16   17   18   19
# -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf    0    0    0    0    0    0    0    0    0    0 -Inf

out1 <- optim(par = rep(0.1, 19), # Инициируем начальные значения параметров - вектор из 19 штук по 0.1
              lLik, # Наша функция, у которой ищем экстремум
              df=df,
              # Укажем ограничения параматров (сравните в консоли, совпадает ли граница с тем, что нам нужно)
              lower = c(rep(-Inf, 8), rep(0, 10), -Inf), # Нижняя граница
              method = "L-BFGS-B" # Метод оптимизации, допускающий ограничения на параметры
)

# Коэффициенты записаны в par, давайте их посмотрим:
out1$par 

# Сделаем красиво
# Создадим столбик названий, для этого опять вспомним порядок параметров
# l <- [1:4] - 4 штуки
# b <- [5:8] - 4 штуки
# a <- [9:13] - 5 штук
# g <- [14:19] - 6 штук

names <- c(
  paste("lam", (1:4)),
  paste("beta", (1:4)),
  paste("alpha",(1:5)),
  paste("gamma",(1:6))
)

# оригинальные результаты BR91
theta.true <- c(
  -0.53, 2.25, 0.34, 0.23, -0.49, -0.03,
  0.004, -0.02, 0.86, 0.03, 0.15, 0, 0.08, 0.53,
  0.76, 0.46, 0.6, 0.12, -0.74
)

our.result <-  round(out1$par,3)
data.frame(names, our.result, theta.true) # красиво
d <- data.frame(names, our.result)






# Идем снова в графики ---------------------------------------------------------

df <- subset(df, select = -TPOP_cut)

calc.S <- function(df, theta) {
  lam <- theta[1:4]
  bet <- theta[5:8]
  alpha <- theta[9:13]
  gam <- theta[14:19]
  df.m <- data.frame(t(colMeans(df)))
  S <- rep(0, 5)
  for (i in 1:5) S[i] <- f(i, gam, df.m) / V(i, alpha, bet, df.m)
  return(S)
}

S <- calc.S(df, out1$par)
plot(S)

plot(S/(1:5))

SN.S5ratio <- (S[5] * (1:5)) / (S * 5)
plot(1:5, SN.S5ratio)










# Ordered probit ---------------------------------------------------------
install.packages('MASS')
library(MASS)

m1 <- polr(
  formula = as.factor(TIRE) ~ TPOP + OPOP + NGRW + PGRW + OCTY + ELD + PINC + LNHDD + FFRAC + LANDV,
  data=df, 
  method=c('probit'),
  Hess=T
)
summary(m1)


