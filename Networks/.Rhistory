# The LGL algorithm is for large connected graphs. Here you can specify a root -
# the node that will be placed in the middle of the layout.
V(karate)$color[2] <- 4
plot(karate, vertex.label=NA, layout = layout_with_lgl, root = 2)
V(karate)$color[2] <- 1
# R decides for you
plot(karate, vertex.label=NA, layout = layout_nicely)
# you can add a layout as a graph characteristic
# it will be fixed and choosen automatically when plotting
karate1 <- add_layout_(karate, in_circle())
plot(karate1)
legend(x=0, y=0, legend = "CIRCLE")
V(karate)$color[20] <- 4
plot(karate, vertex.label=NA)
plot(karate, vertex.label=NA, layout = layout_with_lgl(karate, root = 20))
V(karate)$color[20] <- 1
# R decides for you
plot(karate, vertex.label=NA, layout = layout_nicely)
# numerical characteristics of the graph
vcount(karate)
ecount(karate)
# Density
# The proportion of present edges from all possible ties
edge_density(karate)
edge_density(make_star(10, mode = "undirected"))
edge_density(make_star(14, mode = "undirected"))
# Connectivity
components(karate)
igraph::components(karate) # statnet package has the same function
x <- components(karate)$membership
V(karate)$cluster <- x
V(karate)$cluster
vertex_attr(karate)
deg <- degree(karate) # which.max(deg)
plot(karate, vertex.label=NA, layout = layout_with_fr, vertex.size = deg)
hist(deg, main = "Histogram of node degree", breaks = 1:vcount(karate)-1, prob = TRUE) # degree_distribution
xfit <- seq(min(deg), max(deg), length = 40)
yfit <- dnorm(xfit, mean = mean(deg), sd = sd(deg))
lines(xfit, yfit, col = "black", lwd = 2)
centr_degree(karate) # $res (as in в deg)
clos <- closeness(karate, weights = NA)
plot(karate, vertex.label=NA, layout = layout_with_fr, vertex.size = clos * 1000)
centr_clo(karate) # отличаются от clos умножением на (vcount(karate)-1)
p <- edge_density(karate)
p
g.er <- sample_gnp(n = vcount(karate), p = p)
par(mfrow = c(1, 2))
plot(karate, vertex.label=NA, vertex.color = "yellow")
plot(g.er, vertex.label=NA)
par(mfrow = c(1, 1))
par(mfrow = c(1, 2))
plot(karate, vertex.label=NA, vertex.color = "yellow", layout = layout_in_circle)
plot(g.er, vertex.label=NA, layout = layout_in_circle)
par(mfrow = c(1, 1))
par(mfrow = c(1, 2))
N <- round(1+log(vcount(karate),2))+1
N
hist(degree(karate), main = "Histogram of node degree", breaks = N, prob = TRUE)
hist(degree(g.er), main = "Histogram of node degree", breaks = N, prob = TRUE)
par(mfrow = c(1, 1))
graph_vector <- vector('list', 1000)
mean_dist_vector <- rep(NA, 1000)
for(i in 1:1000){
graph_vector[[i]] <- sample_gnp(n = vcount(karate), p = p)
mean_dist_vector[i] <- mean_distance(graph_vector[[i]])
}
hist(mean_dist_vector)
abline(v = mean_distance(karate, weights = NA), col = "red", lty = 3, lwd = 2)
g.WS <- sample_smallworld(dim = 1, size = 5, nei = 1, p = 0)
plot(g.WS, vertex.label=NA, layout = layout_in_circle, vertex.size = 5)
g.WS <- sample_smallworld(dim = 1, size = vcount(karate), nei = 3, p = 0.05)
plot(g.WS, vertex.label=NA, layout = layout_in_circle, vertex.size = 5)
graph_vector <- vector('list', 1000)
mean_dist_vector <- rep(NA, 1000)
for(i in 1:1000){
graph_vector[[i]] <- sample_smallworld(dim = 1, size = vcount(karate), nei = 2, p = 0.05)
mean_dist_vector[i] <- mean_distance(graph_vector[[i]])
}
hist(mean_dist_vector)
abline(v = mean_distance(karate, weights = NA), col = "red", lty = 3, lwd = 2)
hist(mean_dist_vector, xlim=c(2,5))
abline(v = mean_distance(karate, weights = NA), col = "red", lty = 3, lwd = 2)
g.BA <- sample_pa(n = vcount(karate), power = 1, directed = FALSE)
par(mfrow = c(1, 2))
plot(karate, vertex.label=NA, vertex.color = "yellow")
plot(g.BA, vertex.label=NA)
par(mfrow = c(1, 1))
par(mfrow = c(1, 2))
N <- round(1+log(vcount(karate),2))+1
N
hist(degree(karate), main = "Histogram of node degree", breaks = N, prob = TRUE)
hist(degree(g.BA), main = "Histogram of node degree", breaks = N, prob = TRUE)
par(mfrow = c(1, 1))
p <- edge_density(karate)
assortativity_nominal(karate, types = V(karate)$Faction)
assortativity(karate, types1 = V(karate)$Faction)
assortativity_degree(karate)
# Установим рабочую директорию
setwd("~/Documents/GitHub/RProjects_EF/Networks")
library(igraph);
library(igraphdata);
# library(intergraph);
library(network);
library(tidygraph);
library(ggraph);
library(visNetwork);
library(threejs);
library(networkD3);
edges <- read.csv("edges_1.csv", header=T)
# edges <- edges[1:500, ]
colnames(edges) <- c('from', 'to', 'type1', 'type2', 'weight')
nodes <- unique(edges[c('from', 'type1')])
more_nodes <- unique(edges[c('to', 'type2')])
colnames(nodes) <- c('organisation', 'type')
colnames(more_nodes) <- c('organisation', 'type')
nodes <- rbind(nodes, more_nodes)
nodes <- unique(nodes[c('organisation', 'type')])
rownames(nodes) <- NULL
edges <- edges[c('from', 'to', 'weight')]
# Создадим также набор обратных величин для весов ребер (это пригодится нам в дальнейшем)
edges_inv <- edges
edges_inv$weight <- 1 / edges_inv$weight
net <- graph_from_data_frame(d=edges, vertices=nodes, directed=F)
net_inv <- graph_from_data_frame(d=edges_inv, vertices=nodes, directed=F)
# направленный граф нужен для визуализации графа при помощи пакета ggraph
net_directed <- graph_from_data_frame(d=edges, vertices=nodes, directed=T)
plot(net, layout=layout_nicely)
plot(net, layout=layout_nicely)
plot(net_inv, vertex.label=NA, edge.width=E(net_inv)$weight, layout=layout_nicely)
plot(net_inv, vertex.label=NA, edge.width=E(net_inv)$weight, layout=layout_with_kk)
plot(
net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
vertex.size=degree(net_inv, v=V(net_inv)),
edge.width=E(net_inv)$weight,
layout=layout_nicely
)
plot(
net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
#vertex.size=degree(net_inv, v=V(net_inv)),
edge.width=E(net_inv)$weight,
layout=layout_nicely
)
ceb <- cluster_edge_betweenness(net_inv, weights=E(net_inv)$weight)
mbship_ceb <- membership(ceb)
# mbship_ceb
s_ceb <- sizes(ceb)
s_ceb
ms_ceb <- modularity(ceb)
ms_ceb
ceb
mbship_ceb$1
mbship_ceb$'1'
mbship_ceb$`1`
group_sizes_ceb <- table(mbship_ceb)
group_sizes_ceb <- sort(group_sizes_ceb, decreasing = TRUE)
top_10_groups <- names(group_sizes_ceb)[1:10]
group_sizes_ceb <- table(mbship_ceb)
group_sizes_ceb
group_sizes_ceb <- sort(group_sizes_ceb, decreasing = TRUE)
group_sizes_ceb
top_10_groups <- names(group_sizes_ceb)[1:10]
top_10_groups
group_vertices <- list()
for (group_id in top_10_groups) {
group_indices <- which(mbship_ceb == group_id)
group_vertices[[group_id]] <- names(group_indices)
}
names(group_indices)
group_indices
View(net_inv)
View(net_inv)
View(edges_inv)
View(edges_inv)
group_vertices
group_vertices$`2`
mbship_ceb$`2`
# plot(net_inv, vertex.label=NA, edge.width=E(net_inv)$weight, layout=layout_with_kk)
V(net_inv)$color
# plot(net_inv, vertex.label=NA, edge.width=E(net_inv)$weight, layout=layout_with_kk)
V(net_inv)$color
V(net_inv)$color <- ifelse( V(net_inv)$type=="Business Enterprise", "red",
ifelse( V(net_inv)$type=="Private not for profit", "purple",
ifelse( V(net_inv)$type=="Government", "green",
ifelse( V(net_inv)$type=="Higher Education", "blue", "black") ) ) )
# plot(net_inv, vertex.label=NA, edge.width=E(net_inv)$weight, layout=layout_with_kk)
V(net_inv)$color
plot(
net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
#vertex.size=degree(net_inv, v=V(net_inv)),
edge.width=E(net_inv)$weight,
layout=layout_nicely
)
plot(
net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
#vertex.size=degree(net_inv, v=V(net_inv)),
edge.width=E(net_inv)$weight,
layout=layout_with_lgl
)
plot(
net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
vertex.size=degree(net_inv, v=V(net_inv)),
edge.width=E(net_inv)$weight,
layout=layout_with_lgl
)
plot(ceb, net_inv, layout=layout_nicely)
plot( ceb, net_inv, vertex.color=c("red", "purple", "green", "blue"), layout=layout_nicely )
V(net_inv)$color <- ifelse( V(net_inv)$type=="Business Enterprise", "red",
ifelse( V(net_inv)$type=="Private not for profit", "purple",
ifelse( V(net_inv)$type=="Government", "green",
ifelse( V(net_inv)$type=="Higher Education", "blue", "black") ) ) )
plot( ceb, net_inv, vertex.color=V(net_inv)$color, layout=layout_nicely )
plot( ceb, net_inv, vertex.color=V(net_inv)$color, layout=layout_lgl )
plot( ceb, net_inv, vertex.color=V(net_inv)$color, layout=layout_with_lgl )
plot( ceb, net_inv, vertex.label=NA, vertex.color=V(net_inv)$color, layout=layout_with_lgl )
compare(ceb, net_inv)
compare(ceb, V(net_inv)$type)
data(karate)
p <- edge_density(karate)
# предпочтительное присоединение
# Assortativity / homophily
# The tendency of nodes to connect to others who are similar on some variable.
# assortativity_nominal() is for categorical variables (labels)
# assortativity() is for ordinal and above variables
# assortativity_degree() checks assortativity in node degrees
assortativity_degree(karate)
vertex_attr(karate) # если фракция только 1 или 2, то это одинаковые корреляции будут
assortativity_nominal(karate, types = V(karate)$Faction)
assortativity(karate, types1 = V(karate)$Faction)
gl <- vector('list', 1000)
m <- rep(NA, 1000)
for(i in 1:1000){
gl[[i]] <- erdos.renyi.game(n = gorder(karate), p.or.m = p, type = "gnp")
m[i] <- assortativity(gl[[i]], types1 = sample(V(karate)$Faction))
}
hist(m, xlim = range(c(-1, 1)))
abline(v = assortativity(karate, types1 = V(karate)$Faction), col = "red", lty = 3, lwd = 2)
###########################################
# гомофилия
V(karate)$name <- seq(from = 1, to = 34)
edgeList <- as_edgelist(karate)
faction <- matrix(c(V(karate)$name, V(karate)$Faction), nrow = 34, ncol = 2)
FromLabel <- as.numeric(faction[match(as.numeric(edgeList[,1]), as.numeric(faction[,1])), 2]) # match(x, y) returns a vector with the location of x in y
FromLabel
ToLabel <- as.numeric(faction[match(as.numeric(edgeList[,2]), as.numeric(faction[,1])), 2])
ToLabel
edgeType <- FromLabel + ToLabel
edgeType
faction
table(as.numeric(faction))
faction[,2]
table(edgeType)
table(as.numeric(faction[,2]))
exp_dyad <- table(as.numeric(faction[,2]))[1] * (table(as.numeric(faction[,2]))[1] - 1) * p/2
dyadicity <- table(edgeType)[1] / exp_dyad
exp_hetero <- table(as.numeric(faction[,2]))[1] * table(as.numeric(faction[,2]))[2] * p
heterophilicity <- table(edgeType)[2] / exp_hetero
length(V(net_inv))
V(net_inv)$type
top_10_groups
for (group_id in top_10_groups) {
cat("Группа", group_id, ": ", paste(group_vertices[[group_id]], collapse = ", "), "\n")
}
mbship_ceb$`2`
mbship_ceb$`2`
mbship_ceb$`2`
group_vertices <- list()
for (group_id in top_10_groups) {
group_indices <- which(mbship_ceb == group_id)
group_vertices[[group_id]] <- names(group_indices)
}
group_vertices
group_vertices$`2`
mbship_ceb$`2`
assortativity.nominal(net_inv, V(net_inv)$types, directed=FALSE)
assortativity_nominal(net_inv, V(net_inv)$type, directed=F)
assortativity_nominal(net_inv, V(net_inv)$type, directed=F)
assortativity.nominal(net_inv, V(net_inv)$type, directed=F)
assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
assortativity_gegree(net_inv, directed=F)
assortativity_degree(net_inv, directed=F)
plot( ceb, net_inv, vertex.label=NA, vertex.color=V(net_inv)$color, layout=layout_with_lgl )
V(net_inv)$vertex
V(net_inv)$node
V(net_inv)$nodes
V(net_inv)
V(net_inv)$names
V(net_inv)$name
V(net_inv).where(group_vertices$`2` == V(net_inv)$name)
V(net_inv)which(group_vertices$`2` == V(net_inv)$name)
V(net_inv).which(group_vertices$`2` == V(net_inv)$name)
View(edges)
View(edges)
class(group_vertices)
compare(ceb, V(net_inv)$type, method='nmi') # 3.287989
assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
V(net_inv)$type
sum(is.na(V(net_inv)$type))
assortativity(net_inv, types1=V(net_inv)$type, directed=F)
assortativity(net_inv, types2=V(net_inv)$type, directed=F)
plot( ceb, net_inv, vertex.label=NA, vertex.color=V(net_inv)$color, layout=layout_nicely )
V(net_inv)$num_type <- ifelse( V(net_inv)$type=="Business Enterprise", 1,
ifelse( V(net_inv)$type=="Private not for profit", 2,
ifelse( V(net_inv)$type=="Government", 3,
ifelse( V(net_inv)$type=="Higher Education", 4, 0) ) ) )
assortativity_nominal(net_inv, types=V(net_inv)$num_type, directed=F) #
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 4,
ifelse( V(net_inv)$type=="Government", 3,
ifelse( V(net_inv)$type=="Higher Education", 1, 0) ) ) )
assortativity_nominal(net_inv, types=V(net_inv)$num_type1, directed=F) #
V(net_inv)$color.head()
V(net_inv)$color.head
head(V(net_inv)$color)
unique(V(net_inv)$color)
head(V(net_inv)$color, 10)
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 7,
ifelse( V(net_inv)$type=="Government", 5,
ifelse( V(net_inv)$type=="Higher Education", 10, 0)
)
)
)
assortativity_nominal(net_inv, types=V(net_inv)$num_type1, directed=F) # -0.05876298
# Установим рабочую директорию
setwd("~/Documents/GitHub/RProjects_EF/Networks")
# Подгрузим необходимые для дальнейшего анализа библиотеки
## install.packages("igraph")
## install.packages("igraphdata")
## install.packages("network")
## install.packages("tidygraph")
## install.packages("ggraph")
## install.packages("visNetwork")
## install.packages("threejs")
## install.packages("networkD3")
## install.packages("DigrammeR")
library(igraph);
library(igraphdata);
# library(intergraph);
library(network);
library(tidygraph);
library(ggraph);
library(visNetwork);
library(threejs);
library(networkD3);
# library(DigrammeR);
# Загрузим данные для исследования
edges <- read.csv("edges_1.csv", header=T)
# edges <- edges[1:500, ]
colnames(edges) <- c('from', 'to', 'type1', 'type2', 'weight')
nodes <- unique(edges[c('from', 'type1')])
more_nodes <- unique(edges[c('to', 'type2')])
colnames(nodes) <- c('organisation', 'type')
colnames(more_nodes) <- c('organisation', 'type')
nodes <- rbind(nodes, more_nodes)
nodes <- unique(nodes[c('organisation', 'type')])
rownames(nodes) <- NULL
edges <- edges[c('from', 'to', 'weight')]
# Создадим также набор обратных величин для весов ребер (это пригодится нам в дальнейшем)
edges_inv <- edges
edges_inv$weight <- 1 / edges_inv$weight
net <- graph_from_data_frame(d=edges, vertices=nodes, directed=F)
net_inv <- graph_from_data_frame(d=edges_inv, vertices=nodes, directed=F)
# направленный граф нужен для визуализации графа при помощи пакета ggraph
net_directed <- graph_from_data_frame(d=edges, vertices=nodes, directed=T)
V(net_inv)$color <- ifelse( V(net_inv)$type=="Business Enterprise", "red",
ifelse( V(net_inv)$type=="Private not for profit", "purple",
ifelse( V(net_inv)$type=="Government", "green",
ifelse( V(net_inv)$type=="Higher Education", "blue", "black")
)
)
)
head(V(net_inv)$color, 10)
assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
# Возникли проблемы с вычислением ассортативности через
# assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
# Предупреждение: в результате преобразования созданы NA
# [1] NaN
assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
# Поэтому было принято решение создать новый столбец с закодированными строками
V(net_inv)$num_type <- ifelse( V(net_inv)$type=="Business Enterprise", 1,
ifelse( V(net_inv)$type=="Private not for profit", 2,
ifelse( V(net_inv)$type=="Government", 3,
ifelse( V(net_inv)$type=="Higher Education", 4, 0)
)
)
)
assortativity_nominal(net_inv, types=V(net_inv)$num_type, directed=F) # -0.05876298
# значение ассортативности не зависит от конкретных чисел
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 7,
ifelse( V(net_inv)$type=="Government", 5,
ifelse( V(net_inv)$type=="Higher Education", 10, 0)
)
)
)
assortativity_nominal(net_inv, types=V(net_inv)$num_type1, directed=F) # -0.05876298
assortativity_degree(net_inv, directed=F) # -0.3361749
# Поэтому было принято решение создать новый столбец с закодированными строками
V(net_inv)$num_type <- ifelse( V(net_inv)$type=="Business Enterprise", 1,
ifelse( V(net_inv)$type=="Private not for profit", 2,
ifelse( V(net_inv)$type=="Government", 3,
ifelse( V(net_inv)$type=="Higher Education", 4, 0)
)
)
)
assort_nom <- assortativity_nominal(net_inv, types=V(net_inv)$num_type, directed=F)
assort_nom # -0.05876298
# значение ассортативности не зависит от конкретных чисел
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 7,
ifelse( V(net_inv)$type=="Government", 5,
ifelse( V(net_inv)$type=="Higher Education", 10, 0)
)
)
)
# значение ассортативности не зависит от конкретных чисел
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 7,
ifelse( V(net_inv)$type=="Government", 5,
ifelse( V(net_inv)$type=="Higher Education", 10, 0)
)
)
)
assortativity_nominal(net_inv, types=V(net_inv)$num_type1, directed=F) # -0.05876298
# считаем ассортативность по степени вершины
assort_deg <- assortativity_degree(net_inv, directed=F) # -0.3361749
# считаем ассортативность по степени вершины
assort_deg <- assortativity_degree(net_inv, directed=F) # -0.3361749
assort_deg
# проводим кластеризацию при помощи метода Edge-betweenness
ceb <- cluster_edge_betweenness(net_inv, weights=E(net_inv)$weight)
# смотрим на полученные в результате кластеризации объекты
mbship_ceb <- membership(ceb)
# mbship_ceb
s_ceb <- sizes(ceb)
s_ceb
ms_ceb <- modularity(ceb)
ms_ceb
plot(
ceb, net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
layout=layout_nicely
)
plot(
ceb, net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
layout=layout_with_lgl
)
compare(ceb, V(net_inv)$type, method='nmi') #
# здесь и далее мы используем нормализованное значение функции compare() для облегчения интерпретации возвращаемого результата
# проводим кластеризацию при помощи метода Fast-greedy
cfg <- cluster_fast_greedy(net_inv, weights=E(net_inv)$weight)
# смотрим на полученные в результате кластеризации объекты
mbship_cfg <- membership(cfg)
# mbship_cfg
s_cfg <- sizes(cfg)
s_cfg
ms_cfg <- modularity(cfg)
ms_cfg
plot(
cfg, net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
layout=layout_nicely
)
plot(
cfg, net_inv,
vertex.label=NA,
vertex.color=V(net_inv)$color,
layout=layout_with_lgl
)
compare(cfg, V(net_inv)$type, method='nmi')
compare(ceb, cfg, method='nmi') #
# Возникли проблемы с вычислением ассортативности через
# assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
# Предупреждение: в результате преобразования созданы NA
# [1] NaN
assortativity_nominal(net_inv, types=V(net_inv)$type, directed=F)
# Поэтому было принято решение создать новый столбец с закодированными строками
V(net_inv)$num_type <- ifelse( V(net_inv)$type=="Business Enterprise", 1,
ifelse( V(net_inv)$type=="Private not for profit", 2,
ifelse( V(net_inv)$type=="Government", 3,
ifelse( V(net_inv)$type=="Higher Education", 4, 0)
)
)
)
assort_nom <- assortativity_nominal(net_inv, types=V(net_inv)$num_type, directed=F)
assort_nom # -0.05876298
# значение ассортативности не зависит от конкретных чисел
V(net_inv)$num_type1 <- ifelse( V(net_inv)$type=="Business Enterprise", 2,
ifelse( V(net_inv)$type=="Private not for profit", 7,
ifelse( V(net_inv)$type=="Government", 5,
ifelse( V(net_inv)$type=="Higher Education", 10, 0)
)
)
)
assortativity_nominal(net_inv, types=V(net_inv)$num_type1, directed=F) # -0.05876298
# считаем ассортативность по степени вершины
assort_deg <- assortativity_degree(net_inv, directed=F) # -0.3361749
assort_deg
