# Введение в R
#создадим число
x <- 3

#можем запустить сам объект
x

#можем выполнять арифметические действия
x*3
x + 7
x/5 - 14

#разделителем является точка: три целых и 2 десятых записывается так
3.2

#создадим объект, являющийся преобразованием другого объекта
y <- 11*x + 7

#создадим вектор
a <- c(3, 7, 11)

#операции с векторами
a*6
a + 2
#двойка прибавляется сразу ко всем элементам вектора, умножение также поэлементное

#достанем элемент номер 3 из вектора
a[3]

# скалярное произведение
b <- c(1,2,3)
sum(a * b)
sqrt(sum(a * a)) # длина вектора

#последовательность целых чисел от 1 до 100
x <- 1:100
#а что раньше было в х?

# t <- function(x){
#   y <- x+1
#   print(y)
# }
# t(2)
# теперь R забыл про транспонирование, потому что трнаспонирование -- это тоже t

t1 <- function(x){
  y <- x+1
  print(y)
}
t1(2)



#последовтаельность точек с произвольным шагом
x <- seq(from = -3, to =  4, by = 0.5)
#from - превый элемент, to - последний элемент, by - шаг

rep(a, times = 3)

# замена элементов по правилам
x[x<50] <- 0

#создание матриц
#сначала создадим вектор
b <- c(1, 2, 3, 4)

#превратим его в матрицу:
M <- matrix(b, ncol = 2, nrow = 2)
#ncol - number of columns - число столбцов
#nrow - number of rows - число строк

#выведем матрицу в консоль
M

#видно, что матрица начинает заполняться по столбцам
#перейдем к заполнению по строкам
M2 <- matrix(b, ncol = 2, nrow = 2, byrow = TRUE)
M2
#byrow = TRUE - заполнять по строкам

#достанем элемент 2,2 из матрицы
M[2,2]

#второй столбец
M[,2]

#вторая строка
M[2,]

#иногда удобно записывать вектор сразу в матрицу
M3 <- matrix(c(1, 2,
               3, 4), ncol = 2, nrow = 2, byrow = TRUE)

#можно открыть матрицу в отдельном окне
View(M3)

# матрица специального вида
M4 <- diag(c(1, 2, 3))
M4
diag(M4)

#транспонирование матрицы
rm(t)
t(M)

# найти собственные векторы
eigen(M)
# eigen() decomposition
# $values
# [1]  5.3722813 -0.3722813
# 
# $vectors
# [,1]       [,2]
# [1,] -0.5657675 -0.9093767
# [2,] -0.8245648  0.4159736

#находим обратную матрицу, т.к. b undefined
solve(M)


#умножение матрицы на вектор
d <- c(5, 6)
M %*% d

#умножение матрицы на матрицу
M5 <- matrix(c(4, 11,
               5, 9), ncol = 2, nrow = 2, byrow = TRUE)
M %*% M5

round(solve(M5), 2)

# сцепление матриц
cbind(M, M5)


#решение системы неоднородных уравнений: Mx = b, причем эта функцяи ищет решение
# только, если оно единственное
b <- c(4, -1)
solve(M, b)

View(solve) # посмотреть, как устроена функция solve


#определение размера матрицы
dim(M)

#определитель матрицы
det(M)

# найти след матрицы
sum(diag(M))

#построим график параболы 
x <- -10:10
y <- x^2
plot(x, y)

#можно соединить точки линиями
plot(x, y, type = "l")

# создание функций
f <- function(x){
  t <- x+3
  return(t)
}
f(3)






# МНК-оценки (как это было в линале)
#Создадим три вектора. Например, вот такие:
x <- c(0,0,1,1,1)
y <- c(5,3,5,6,7)
const <- c(1,1,1,1,1)

#Можно склеить два вектора в один очень длинный вектор
q <- c(const,x)
#Из такого вектора можно собрать матрицу
X <- matrix(q, nrow=5, ncol=2, byrow=FALSE)
X

#Пример матричных вычислений. Вычислим (X'X)
t(X) %*% X

#Пример матричных вычислений. Вычислим (X'X)^(-1)*(X'y)
#Что за вектор мы получим в результате?
beta <- solve(t(X) %*% X) %*% t(X) %*% y  
beta
# [,1]
# [1,]    4
# [2,]    2

# =>
# \hat{y_i} = 4 + 2 * x_i


# оптимизация функций
# https://cran.r-project.org/web/views/Optimization.html
# https://web.stanford.edu/~boyd/papers/pdf/cvxr_paper.pdf

f <- function(x) {
  x1 <- x[1]
  x2 <- x[2]
  2*(x1-1)^2 + 5*(x2-3)^2 + 10
}
r <- optim(c(0,0), f)
r
# $par
# [1] 0.9997405 2.9998928
# 
# $value
# [1] 10
# 
# $counts
# function gradient 
# 67       NA 
# 
# $convergence
# [1] 0
# 
# $message
# NULL

# нелинейная оптимизация с ограничениями в соответствующей теме


#Вам не нужно помнить названия всех команд наизусть
#Можно посмотреть, например, здесь: http://www.statmethods.net/advstats/matrix.html






###############
##### ЗЛП #####
###############

## все ограничения должны иметь вид: Ax <= b
C <- c(0.3, 0.9) # целевая функция (min укажем далее)
# нужно обязательно задавать ограниченное мн-во, чтобы все получилось
A <- matrix(c(-1, -1,
              0.21, -0.3,
              -0.03, 0.01,
              1, 0,
              0, 1), byrow = TRUE, ncol = 2, nrow = 5)
b <- c(-800, 0, 0, 1000, 1000)
# -x_1 - x_2 <= -800
# 0.21 * x_1 - 0.3 * x_2 <= 0
# -0.03 * x_1 + 0 * x_2 <= 0
# x_1 + 0 * x_2 <= 1000
# 0 * x_1 + x_2 <= 1000
# x_j >= 0

#установим пакеты для графического решения
#install.packages("manipulateWidget")
install.packages("rgl") #спрашивает разрешение на компиляцию
install.packages("gMOIP") #спрашивает разрешение на компиляцию, рисует графики

#подгрузим библиотеки
# options(rgl.useNULL = TRUE) #оказалось не обязательно запускать эту строку
library(rgl)
library(gMOIP)
library(ggplot2)


#построим графическое решение задачи
p <- plotPolytope(
  A,
  b,
  obj = C,
  crit = "min", # целевая функция на min
  plotFeasible = TRUE, # рисовать ДМ
  plotOptimum = TRUE, # рисовать оптимум
  labels = "coord",
  nonneg = c(TRUE, TRUE)
) + xlab("x1") + ylab("x2") + xlim(0, 1000) + ylim(0, 1000)
p

# чтобы область была красивой -- нужно чтобы была ограниченной

#задача на минимум или на максимум
#plotFeasible = TRUE - если область допустимых решений ограничена - закрасить ее
#plotOptimum = TRUE - добавить значение целевой функции в точке оптимума
#labels = "coord" - подписывать вершины координатам
#+ xlab("x") - подписывать горизонтальную ось как "x"
#nonneg = c(TRUE, TRUE) - переменные не отрицательны? 
#если есть 3 переменные, 2 неотрицательные, а третья без ограничений, тогда 
#nonneg = c(TRUE, TRUE, FALSE)




### Испортим задачу:
C1 <- c(0.3, 0.9)
A1 <- matrix(c(-1, -1,
              0.21, -0.3,
              -0.03, 0.01), byrow = TRUE, ncol = 2, nrow = 5)
b1 <- c(-800, 0, 0, 1000, 1000)

p1 <- plotPolytope(
  A1,
  b1,
  obj = C1,
  crit = "min", # целевая функция на min
  plotFeasible = TRUE, # рисовать ДМ
  plotOptimum = TRUE, # рисовать оптимум
  labels = "coord",
  nonneg = c(TRUE, TRUE)
) + xlab("x1") + ylab("x2") + xlim(0, 1000) + ylim(0, 1000)
p1